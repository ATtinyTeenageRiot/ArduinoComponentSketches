/**
   ACS-85-0050
   ATTiny85  PWM Sinewave with distortion and rectification

   External pin 1       = Reset (not used)
   External pin 2 (PB3) = input 0 freq 1
   External pin 3 (PB4) = output
   External pin 4       = GND
   External pin 5 (PB0) = rectify 
   External pin 6 (PB1) = distortion
   External pin 7 (PB2) = TBD
   External pin 8       = Vcc


   Inspired from a collection of snippets from 
   http://www.technoblogy.com

   V 1.0  -  First Version

   Rob Stave (Rob the fiddler) ccby 2018
*/

//  ATTiny overview
//                      +-\/-+
//               Reset 1|    |8  VCC
// (pin3) in 0 A3  PB3 2| AT |7  PB2 (pin2) TBD
// (pin4) out PWM  PB4 3| 85 |6  PB1 (pin1) clip
//                 GND 4|    |5  PB0 (pin0) rectify
//                      +----+


unsigned int accumulator;
unsigned int note;

volatile boolean rectify = false;
volatile boolean clip = false;

const int NOTE_MIN = 500;
const int NOTE_MAX = NOTE_MIN + 1023;

static uint8_t sinewave_values[] = {
  0x80, 0x83, 0x86, 0x89, 0x8c, 0x8f, 0x92, 0x95, 0x98, 0x9c, 0x9f, 0xa2, 0xa5, 0xa8, 0xab, 0xae,
  0xb0, 0xb3, 0xb6, 0xb9, 0xbc, 0xbf, 0xc1, 0xc4, 0xc7, 0xc9, 0xcc, 0xce, 0xd1, 0xd3, 0xd5, 0xd8,
  0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xed, 0xef, 0xf0, 0xf2, 0xf3, 0xf5,
  0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfd, 0xfc, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7,
  0xf6, 0xf5, 0xf3, 0xf2, 0xf0, 0xef, 0xed, 0xec, 0xea, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0, 0xde, 0xdc,
  0xda, 0xd8, 0xd5, 0xd3, 0xd1, 0xce, 0xcc, 0xc9, 0xc7, 0xc4, 0xc1, 0xbf, 0xbc, 0xb9, 0xb6, 0xb3,
  0xb0, 0xae, 0xab, 0xa8, 0xa5, 0xa2, 0x9f, 0x9c, 0x98, 0x95, 0x92, 0x8f, 0x8c, 0x89, 0x86, 0x83,
  0x80, 0x7c, 0x79, 0x76, 0x73, 0x70, 0x6d, 0x6a, 0x67, 0x63, 0x60, 0x5d, 0x5a, 0x57, 0x54, 0x51,
  0x4f, 0x4c, 0x49, 0x46, 0x43, 0x40, 0x3e, 0x3b, 0x38, 0x36, 0x33, 0x31, 0x2e, 0x2c, 0x2a, 0x27,
  0x25, 0x23, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x17, 0x15, 0x13, 0x12, 0x10, 0x0f, 0x0d, 0x0c, 0x0a,
  0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x03, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
  0x09, 0x0a, 0x0c, 0x0d, 0x0f, 0x10, 0x12, 0x13, 0x15, 0x17, 0x19, 0x1b, 0x1d, 0x1f, 0x21, 0x23,
  0x25, 0x27, 0x2a, 0x2c, 0x2e, 0x31, 0x33, 0x36, 0x38, 0x3b, 0x3e, 0x40, 0x43, 0x46, 0x49, 0x4c,
  0x4f, 0x51, 0x54, 0x57, 0x5a, 0x5d, 0x60, 0x63, 0x67, 0x6a, 0x6d, 0x70, 0x73, 0x76, 0x79, 0x7c
};

void setup() {
  // Enable 64 MHz PLL and use as source for Timer1
  PLLCSR = 1 << PCKE | 1 << PLLE;

  // Set up Timer/Counter1 for PWM output
  TIMSK = 0;                     // Timer interrupts OFF
  TCCR1 = 1 << CS10;             // 1:1 prescale
  GTCCR = 1 << PWM1B | 2 << COM1B0; // PWM B, clear on match

  pinMode(4, OUTPUT);            // Enable PWM output pin

  // Set up Timer/Counter0 for 20kHz interrupt to output samples.
  TCCR0A = 3 << WGM00;           // Fast PWM
  TCCR0B = 1 << WGM02 | 2 << CS00; // 1/8 prescale
  TIMSK = 1 << OCIE0A;           // Enable compare match, disable overflow
  OCR0A = 49;                    // Divide by 400
}



ISR(TIMER0_COMPA_vect) {
  accumulator = accumulator + note;
  uint8_t value;

  if (rectify == false) {
    value = sinewave_values[accumulator >> 8];
  } else {
    //just use upper half
    value = sinewave_values[accumulator >> 9];
  }

  if (clip){
    if ( value > 235){
      value = 235;
    } else if (value < 40){
      value = 40;
    }
  }

  OCR1B  = value;
}

boolean checkRectify() {
  // Check pin 0
  return ((PINB & 0b00000001) != 0);
}

boolean checkClip() {
  // Check pin 1
  return ((PINB & 0b00000010) != 0);
}

void loop() {
  int sample = 0;
  byte count = 0;
  while (true) {

    count++;
    sample = analogRead(A3);
    note = map(sample, 0, 1023, NOTE_MIN, NOTE_MAX );

    if (count == 7) {
      if (checkRectify()) {
        rectify = true;
      } else {
        rectify = false;
      }
      if (checkClip()) {
        clip = true;
      } else {
        clip = false;
      }

    }
    if (count > 8) {
      count = 0;
    }
  }
}
